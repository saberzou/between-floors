// Grainient â€” WebGL animated grain gradient background
// Ported from react-bits (MIT) to vanilla JS with OGL

const GRAINIENT_VERTEX = `#version 300 es
in vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

const GRAINIENT_FRAGMENT = `#version 300 es
precision highp float;
uniform vec2 iResolution;
uniform float iTime;
uniform float uTimeSpeed;
uniform float uColorBalance;
uniform float uWarpStrength;
uniform float uWarpFrequency;
uniform float uWarpSpeed;
uniform float uWarpAmplitude;
uniform float uBlendAngle;
uniform float uBlendSoftness;
uniform float uRotationAmount;
uniform float uNoiseScale;
uniform float uGrainAmount;
uniform float uGrainScale;
uniform float uGrainAnimated;
uniform float uContrast;
uniform float uGamma;
uniform float uSaturation;
uniform vec2 uCenterOffset;
uniform float uZoom;
uniform vec3 uColor1;
uniform vec3 uColor2;
uniform vec3 uColor3;
out vec4 fragColor;
#define S(a,b,t) smoothstep(a,b,t)
mat2 Rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}
vec2 hash(vec2 p){p=vec2(dot(p,vec2(2127.1,81.17)),dot(p,vec2(1269.5,283.37)));return fract(sin(p)*43758.5453);}
float noise(vec2 p){vec2 i=floor(p),f=fract(p),u=f*f*(3.0-2.0*f);float n=mix(mix(dot(-1.0+2.0*hash(i+vec2(0.0,0.0)),f-vec2(0.0,0.0)),dot(-1.0+2.0*hash(i+vec2(1.0,0.0)),f-vec2(1.0,0.0)),u.x),mix(dot(-1.0+2.0*hash(i+vec2(0.0,1.0)),f-vec2(0.0,1.0)),dot(-1.0+2.0*hash(i+vec2(1.0,1.0)),f-vec2(1.0,1.0)),u.x),u.y);return 0.5+0.5*n;}
void mainImage(out vec4 o, vec2 C){
  float t=iTime*uTimeSpeed;
  vec2 uv=C/iResolution.xy;
  float ratio=iResolution.x/iResolution.y;
  vec2 tuv=uv-0.5+uCenterOffset;
  tuv/=max(uZoom,0.001);
  float degree=noise(vec2(t*0.1,tuv.x*tuv.y)*uNoiseScale);
  tuv.y*=1.0/ratio;
  tuv*=Rot(radians((degree-0.5)*uRotationAmount+180.0));
  tuv.y*=ratio;
  float frequency=uWarpFrequency;
  float ws=max(uWarpStrength,0.001);
  float amplitude=uWarpAmplitude/ws;
  float warpTime=t*uWarpSpeed;
  tuv.x+=sin(tuv.y*frequency+warpTime)/amplitude;
  tuv.y+=sin(tuv.x*(frequency*1.5)+warpTime)/(amplitude*0.5);
  vec3 colLav=uColor1;
  vec3 colOrg=uColor2;
  vec3 colDark=uColor3;
  float b=uColorBalance;
  float s=max(uBlendSoftness,0.0);
  mat2 blendRot=Rot(radians(uBlendAngle));
  float blendX=(tuv*blendRot).x;
  float edge0=-0.3-b-s;
  float edge1=0.2-b+s;
  float v0=0.5-b+s;
  float v1=-0.3-b-s;
  vec3 layer1=mix(colDark,colOrg,S(edge0,edge1,blendX));
  vec3 layer2=mix(colOrg,colLav,S(edge0,edge1,blendX));
  vec3 col=mix(layer1,layer2,S(v0,v1,tuv.y));
  vec2 grainUv=uv*max(uGrainScale,0.001);
  if(uGrainAnimated>0.5){grainUv+=vec2(iTime*0.05);}
  float grain=fract(sin(dot(grainUv,vec2(12.9898,78.233)))*43758.5453);
  col+=(grain-0.5)*uGrainAmount;
  col=(col-0.5)*uContrast+0.5;
  float luma=dot(col,vec3(0.2126,0.7152,0.0722));
  col=mix(vec3(luma),col,uSaturation);
  col=pow(max(col,0.0),vec3(1.0/max(uGamma,0.001)));
  col=clamp(col,0.0,1.0);
  o=vec4(col,1.0);
}
void main(){
  vec4 o=vec4(0.0);
  mainImage(o,gl_FragCoord.xy);
  fragColor=o;
}
`;

function hexToRgb(hex) {
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!r) return [1, 1, 1];
    return [parseInt(r[1], 16) / 255, parseInt(r[2], 16) / 255, parseInt(r[3], 16) / 255];
}

function lerpColor(a, b, t) {
    return [a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t, a[2] + (b[2] - a[2]) * t];
}

function initGrainient(container, initialColors) {
    const { Renderer, Program, Mesh, Triangle } = window.OGL || {};
    if (!Renderer) { console.warn('OGL not loaded'); return null; }

    const renderer = new Renderer({
        webgl: 2,
        alpha: true,
        antialias: false,
        dpr: Math.min(window.devicePixelRatio || 1, 2)
    });

    const gl = renderer.gl;
    const canvas = gl.canvas;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    container.appendChild(canvas);

    const geometry = new Triangle(gl);
    const c1 = hexToRgb(initialColors[0]);
    const c2 = hexToRgb(initialColors[1]);
    const c3 = hexToRgb(initialColors[2]);

    const program = new Program(gl, {
        vertex: GRAINIENT_VERTEX,
        fragment: GRAINIENT_FRAGMENT,
        uniforms: {
            iTime: { value: 0 },
            iResolution: { value: new Float32Array([1, 1]) },
            uTimeSpeed: { value: 0.15 },
            uColorBalance: { value: 0.0 },
            uWarpStrength: { value: 1.0 },
            uWarpFrequency: { value: 4.0 },
            uWarpSpeed: { value: 1.5 },
            uWarpAmplitude: { value: 60.0 },
            uBlendAngle: { value: 0.0 },
            uBlendSoftness: { value: 0.05 },
            uRotationAmount: { value: 400.0 },
            uNoiseScale: { value: 2.0 },
            uGrainAmount: { value: 0.12 },
            uGrainScale: { value: 2.0 },
            uGrainAnimated: { value: 1.0 },
            uContrast: { value: 1.4 },
            uGamma: { value: 1.0 },
            uSaturation: { value: 0.8 },
            uCenterOffset: { value: new Float32Array([0, 0]) },
            uZoom: { value: 0.9 },
            uColor1: { value: new Float32Array(c1) },
            uColor2: { value: new Float32Array(c2) },
            uColor3: { value: new Float32Array(c3) }
        }
    });

    const mesh = new Mesh(gl, { geometry, program });

    function setSize() {
        const rect = container.getBoundingClientRect();
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        renderer.setSize(w, h);
        program.uniforms.iResolution.value[0] = gl.drawingBufferWidth;
        program.uniforms.iResolution.value[1] = gl.drawingBufferHeight;
    }

    const ro = new ResizeObserver(setSize);
    ro.observe(container);
    setSize();

    let raf = 0;
    const t0 = performance.now();

    // Target colors for smooth transitions
    let targetC1 = c1.slice(), targetC2 = c2.slice(), targetC3 = c3.slice();
    let currentC1 = c1.slice(), currentC2 = c2.slice(), currentC3 = c3.slice();

    function loop(t) {
        program.uniforms.iTime.value = (t - t0) * 0.001;

        // Lerp colors toward target
        const speed = 0.03;
        for (let i = 0; i < 3; i++) {
            currentC1[i] += (targetC1[i] - currentC1[i]) * speed;
            currentC2[i] += (targetC2[i] - currentC2[i]) * speed;
            currentC3[i] += (targetC3[i] - currentC3[i]) * speed;
        }
        program.uniforms.uColor1.value.set(currentC1);
        program.uniforms.uColor2.value.set(currentC2);
        program.uniforms.uColor3.value.set(currentC3);

        renderer.render({ scene: mesh });
        raf = requestAnimationFrame(loop);
    }
    raf = requestAnimationFrame(loop);

    return {
        setColors(hex1, hex2, hex3) {
            targetC1 = hexToRgb(hex1);
            targetC2 = hexToRgb(hex2);
            targetC3 = hexToRgb(hex3);
        },
        destroy() {
            cancelAnimationFrame(raf);
            ro.disconnect();
            try { container.removeChild(canvas); } catch {}
        }
    };
}
